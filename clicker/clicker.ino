#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <Mouse.h>
#include <Keyboard.h>

Adafruit_SSD1306 display(128, 64, &Wire, -1);

int leftButton = 6;
int centerButton = 7;
int rightButton = 5;
int bluetooth = 11;

int lightPin = 8;

bool toolMode = true; //used in mining mode to save if it has a shovel or pickaxe
int newMode = 0; 

int transition1 = 0; //for when moving left and right to switch modes

volatile byte state = LOW; //saved if button is pressed

//icons for modes
const unsigned char pickaxe [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x07, 
  0xf8, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x00, 0x00, 0x00, 0x03, 0xff, 0x80, 0x00, 0x00, 0x00, 0x1f, 
  0x80, 0x00, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x3f, 0xcf, 0xff, 0xe0, 0x00, 0x7b, 0xcf, 
  0x0f, 0xe0, 0x00, 0xf3, 0xcf, 0x1f, 0xe0, 0x01, 0xe3, 0xcf, 0x9f, 0x20, 0x03, 0xc3, 0xcf, 0x06, 
  0x20, 0x07, 0x83, 0xce, 0x30, 0x20, 0x0f, 0x1b, 0xcc, 0x70, 0x60, 0x1e, 0x39, 0x88, 0xf9, 0xe0, 
  0x3c, 0x7c, 0x01, 0xf9, 0xe0, 0x78, 0xf8, 0x00, 0x79, 0xe0, 0xf1, 0xfb, 0xe0, 0x79, 0x20, 0xe1, 
  0xf9, 0xc7, 0x01, 0x20, 0x01, 0x80, 0x0f, 0xc0, 0x20, 0x01, 0x80, 0x1f, 0xe0, 0x20, 0x01, 0xc6, 
  0x3f, 0xe6, 0x20, 0x01, 0xe4, 0x03, 0x8f, 0x20, 0x01, 0xe0, 0x00, 0x1f, 0xe0, 0x01, 0x20, 0x08, 
  0x1f, 0xe0, 0x01, 0x26, 0x3f, 0x8f, 0xe0, 0x01, 0x3f, 0x3f, 0x83, 0xe0, 0x01, 0x3f, 0x9f, 0x81, 
  0xe0, 0x01, 0x1c, 0x07, 0x18, 0x20, 0x01, 0x0c, 0xe0, 0x7e, 0x20, 0x01, 0x8f, 0xf0, 0x7e, 0x60, 
  0x01, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char elytra [] PROGMEM = { 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xfe, 0x0f, 0xe0, 0x0, 0x00, 0xfe, 0x0f, 0xe0, 0x00, 0x00, 0xfe, 0x0f, 0xe0, 0x00, 0x1f, 0x07, 
  0xfc, 0x1f, 0x00, 0x1f, 0x07, 0xfc, 0x1f, 0x00, 0xe0, 0x06, 0x0c, 0x00, 0xe0, 0xe0, 0x06, 0x0c, 
  0x00, 0xe0, 0xe0, 0x06, 0x0c, 0x00, 0xe0, 0xe0, 0x06, 0x0c, 0x00, 0xe0, 0xe0, 0x06, 0x0c, 0x00, 
  0xe0, 0xe0, 0x06, 0x0c, 0x00, 0xe0, 0xe0, 0x06, 0x0c, 0x00, 0xe0, 0xe0, 0x06, 0x0c, 0x00, 0xe0, 
  0xe0, 0x06, 0x0c, 0x00, 0xe0, 0xe0, 0x06, 0x0c, 0x00, 0xe0, 0xe0, 0x06, 0x0c, 0x00, 0xe0, 0xe0, 
  0x06, 0x0c, 0x00, 0xe0, 0xe0, 0x06, 0x0c, 0x00, 0xe0, 0xe0, 0x06, 0x0c, 0x00, 0xe0, 0xe0, 0x06, 
  0x0c, 0x00, 0xe0, 0x18, 0x06, 0x0c, 0x03, 0x00, 0x18, 0x06, 0x0c, 0x03, 0x00, 0x18, 0x06, 0x0c, 
  0x03, 0x00, 0x18, 0x06, 0x0c, 0x03, 0x00, 0x18, 0x06, 0x0c, 0x03, 0x00, 0x07, 0x38, 0x03, 0x9c, 
  0x00, 0x07, 0x38, 0x03, 0x9c, 0x00, 0x07, 0xc0, 0x00, 0x7c, 0x00, 0x07, 0xc0, 0x00, 0x7c, 0x00, 
  0x07, 0xc0, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char endBridging [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x0e, 0x1c, 0x00, 0x00, 0x00, 0x10, 0x02, 0x00, 0x00, 0x00, 0x23, 0xf1, 
  0x00, 0x00, 0x00, 0x67, 0xf9, 0x80, 0x00, 0x00, 0x6f, 0x3d, 0x8f, 0xff, 0xe0, 0x8e, 0x1c, 0x4e, 
  0x0f, 0xe0, 0x8e, 0x1c, 0x4c, 0x1f, 0xe0, 0x8e, 0x1c, 0x48, 0x1f, 0x20, 0x8e, 0x1c, 0x4c, 0x06, 
  0x20, 0x4f, 0x3c, 0x8c, 0x30, 0x20, 0x67, 0xbd, 0x8c, 0x70, 0x60, 0x63, 0xf9, 0x88, 0xf9, 0xe0, 
  0x10, 0x02, 0x39, 0xf9, 0xe0, 0x00, 0x00, 0x30, 0x79, 0xe0, 0x0e, 0x1c, 0x70, 0x79, 0x20, 0x01, 
  0xe0, 0xc7, 0x01, 0x20, 0x00, 0x00, 0x0f, 0xc0, 0x20, 0x00, 0x00, 0x1f, 0xe0, 0x20, 0x01, 0xc6, 
  0x3f, 0xe6, 0x20, 0x01, 0xe4, 0x03, 0x8f, 0x20, 0x01, 0xe0, 0x00, 0x1f, 0xe0, 0x01, 0x20, 0x08, 
  0x1f, 0xe0, 0x01, 0x26, 0x3f, 0x8f, 0xe0, 0x01, 0x3f, 0x3f, 0x83, 0xe0, 0x01, 0x3f, 0x9f, 0x81, 
  0xe0, 0x01, 0x1c, 0x07, 0x18, 0x20, 0x01, 0x0c, 0xe0, 0x7e, 0x20, 0x01, 0x8f, 0xf0, 0x7e, 0x60, 
  0x01, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char crystal [] PROGMEM = {
  0x7f, 0xff, 0xff, 0xff, 0xc0, 0x7f, 0xff, 0xff, 0xff, 0xc0, 0x78, 0x01, 0xf0, 0x03, 0xc0, 0x70, 
  0x00, 0xe0, 0x01, 0xc0, 0x70, 0x00, 0xe0, 0x01, 0xc0, 0x70, 0x03, 0xf8, 0x01, 0xc0, 0x70, 0x03, 
  0xf8, 0x01, 0xc0, 0x70, 0x07, 0xfc, 0x01, 0xc0, 0x70, 0x0f, 0xff, 0x01, 0xc0, 0x70, 0x1f, 0xff, 
  0x01, 0xc0, 0x70, 0x7f, 0xe7, 0xc1, 0xc0, 0x70, 0x7f, 0xe7, 0xc1, 0xc0, 0x70, 0x3f, 0x8f, 0xc1, 
  0xc0, 0x71, 0x9f, 0x9f, 0xc1, 0xc0, 0x73, 0x9f, 0x1f, 0xc1, 0xc0, 0x7f, 0xfc, 0x1f, 0x31, 0xc0, 
  0x7f, 0xfc, 0x1f, 0x39, 0xc0, 0x7f, 0xf0, 0x00, 0x7f, 0xc0, 0x7f, 0xf0, 0x60, 0xff, 0xc0, 0x7f, 
  0xf0, 0xe1, 0xff, 0xc0, 0x73, 0xff, 0xff, 0xf9, 0xc0, 0x73, 0xff, 0xff, 0xf9, 0xc0, 0x70, 0xf7, 
  0x8f, 0xe1, 0xc0, 0x70, 0x73, 0x87, 0xe1, 0xc0, 0x70, 0x67, 0x87, 0xc1, 0xc0, 0x70, 0x1f, 0xff, 
  0x01, 0xc0, 0x70, 0x1f, 0xff, 0x01, 0xc0, 0x70, 0x07, 0xfc, 0x01, 0xc0, 0x70, 0x03, 0xfc, 0x01, 
  0xc0, 0x70, 0x03, 0xf8, 0x01, 0xc0, 0x70, 0x00, 0xe0, 0x01, 0xc0, 0x70, 0x00, 0xe0, 0x01, 0xc0, 
  0x78, 0x01, 0xf0, 0x03, 0xc0, 0x7f, 0xff, 0xff, 0xff, 0xc0, 0x7f, 0xff, 0xff, 0xff, 0xc0
};

const unsigned char sword [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 0xf3, 0x00, 0x00, 0x00, 
  0x01, 0xe3, 0x00, 0x00, 0x00, 0x03, 0xc7, 0x00, 0x00, 0x00, 0x07, 0x8f, 0x00, 0x00, 0x00, 0x0f, 
  0x1e, 0x00, 0x00, 0x00, 0x1e, 0x3c, 0x00, 0x00, 0x00, 0x3c, 0x78, 0x00, 0x00, 0x00, 0x78, 0xf0, 
  0x00, 0x07, 0x80, 0xf1, 0xe0, 0x00, 0x07, 0xc1, 0xe3, 0xc0, 0x00, 0x07, 0xc3, 0xc7, 0x80, 0x00, 
  0x07, 0xf3, 0x8f, 0x00, 0x00, 0x03, 0xf3, 0x1e, 0x00, 0x00, 0x00, 0xf6, 0x3c, 0x00, 0x00, 0x00, 
  0xfe, 0x78, 0x00, 0x00, 0x00, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x7f, 0x80, 0x00, 0x00, 0x00, 0x3f, 
  0x00, 0x00, 0x00, 0x00, 0xff, 0xe0, 0x00, 0x00, 0x00, 0xff, 0xe0, 0x00, 0x00, 0x03, 0xf7, 0xf8, 
  0x00, 0x00, 0x03, 0xf3, 0xfc, 0x00, 0x00, 0x0f, 0xc0, 0x7c, 0x00, 0x00, 0x1f, 0xc0, 0x7c, 0x00, 
  0x00, 0x1f, 0x00, 0x3c, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char button [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x80, 0x00, 
  0x20, 0x00, 0x00, 0x80, 0x00, 0x20, 0x00, 0x00, 0x80, 0x00, 0x20, 0x00, 0x00, 0x80, 0x00, 0x20, 
  0x00, 0x00, 0x80, 0x00, 0x20, 0x00, 0x00, 0x80, 0x00, 0x20, 0x00, 0x00, 0x80, 0x00, 0x20, 0x00, 
  0x00, 0x80, 0x00, 0x20, 0x00, 0x00, 0x80, 0x00, 0x20, 0x7f, 0x80, 0x80, 0x00, 0x20, 0x7f, 0x80, 
  0x80, 0x00, 0x20, 0x03, 0x80, 0x80, 0x00, 0x20, 0xfb, 0x80, 0x80, 0x00, 0x21, 0x0b, 0x80, 0x80, 
  0x00, 0x22, 0x0b, 0x80, 0x80, 0x00, 0x04, 0x08, 0x00, 0x80, 0x00, 0x08, 0x08, 0x00, 0x80, 0x00, 
  0x04, 0x10, 0x00, 0x80, 0x00, 0x04, 0x20, 0x00, 0x80, 0x00, 0x0b, 0x40, 0x00, 0x80, 0x00, 0x14, 
  0x80, 0x00, 0x80, 0x00, 0x28, 0x00, 0x00, 0x80, 0x00, 0x50, 0x3f, 0xff, 0x80, 0x00, 0xa0, 0x00, 
  0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x02, 0x80, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
  0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 
  0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char logo [] PROGMEM = {
  0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xfc, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x07, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x80, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x07, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xc0, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x07, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xc0, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x07, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x07, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xe3, 0xff, 0xfc, 0x00, 
  0x00, 0x00, 0x07, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf7, 0xff, 0xfc, 0x00, 
  0x00, 0x00, 0x07, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7d, 0xf7, 0xc1, 0xfc, 0x00, 
  0x00, 0x00, 0x07, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf9, 0xf7, 0xe3, 0xfc, 0x00, 
  0x00, 0x00, 0x07, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf1, 0xf7, 0xe7, 0xe4, 0x00, 
  0x3f, 0xff, 0x87, 0xfc, 0x1f, 0xfe, 0x78, 0x00, 0x3c, 0x00, 0x03, 0xe1, 0xf7, 0xc0, 0xc4, 0x00, 
  0x7f, 0xff, 0xc7, 0xfc, 0x3f, 0xfe, 0x7c, 0x00, 0x7c, 0x00, 0x07, 0xc1, 0xf7, 0x80, 0x04, 0x00, 
  0xff, 0xff, 0xe7, 0xfc, 0x7f, 0xfe, 0x7e, 0x00, 0xfc, 0x00, 0x0f, 0x89, 0xf7, 0x1e, 0x04, 0x00, 
  0xff, 0xff, 0xe7, 0xfc, 0x7f, 0xfc, 0x7f, 0x01, 0xfc, 0x00, 0x1e, 0x18, 0xc6, 0x3f, 0x3c, 0x00, 
  0xff, 0xff, 0xe7, 0xfc, 0x7f, 0xf8, 0x7f, 0x83, 0xfc, 0x00, 0x3e, 0x3c, 0x40, 0x7f, 0x3c, 0x00, 
  0xfe, 0x07, 0xe7, 0xfc, 0x7c, 0x00, 0x3f, 0xc7, 0xf8, 0x00, 0x7c, 0x7e, 0x00, 0x7f, 0x3c, 0x00, 
  0xfe, 0x07, 0xe7, 0xfc, 0x7c, 0x00, 0x1f, 0xff, 0xe0, 0x00, 0xf0, 0xfd, 0xf8, 0x1f, 0x24, 0x00, 
  0xfc, 0x07, 0xe7, 0xfc, 0x7c, 0x00, 0x0f, 0xff, 0xe0, 0x00, 0xf1, 0xf8, 0xf8, 0x0f, 0x24, 0x00, 
  0x00, 0x07, 0xe7, 0xfe, 0x7f, 0xf8, 0x07, 0xff, 0xc0, 0x00, 0xe1, 0xf8, 0x71, 0xc0, 0x24, 0x00, 
  0x3f, 0xff, 0xe7, 0xfe, 0x7f, 0xfe, 0x03, 0xff, 0x00, 0x00, 0x01, 0x80, 0x03, 0xf8, 0x04, 0x00, 
  0x3f, 0xff, 0xe7, 0xfe, 0x7f, 0xfe, 0x01, 0xff, 0x00, 0x00, 0x01, 0x80, 0x07, 0xf8, 0x04, 0x00, 
  0xff, 0xff, 0xe7, 0xfe, 0x7f, 0xfe, 0x01, 0xff, 0x00, 0x00, 0x01, 0xc3, 0x8f, 0xf8, 0xc4, 0x00, 
  0xfe, 0x0f, 0xe7, 0xfe, 0x7f, 0xfc, 0x03, 0xff, 0x80, 0x00, 0x01, 0xf3, 0x00, 0xf1, 0xe4, 0x00, 
  0xfe, 0x07, 0xe7, 0xfe, 0x7f, 0xf8, 0x07, 0xff, 0xc0, 0x00, 0x01, 0xf2, 0x00, 0x63, 0xe4, 0x00, 
  0xfe, 0x07, 0xe7, 0xfe, 0x7c, 0x00, 0x0f, 0xff, 0xe0, 0x00, 0x01, 0xb0, 0x06, 0x07, 0xfc, 0x00, 
  0xfe, 0x07, 0xe7, 0xfe, 0x7c, 0x00, 0x1f, 0xcf, 0xf0, 0x00, 0x01, 0xb3, 0x0f, 0xe3, 0xfc, 0x00, 
  0xfe, 0x07, 0xe7, 0xfe, 0x7c, 0x00, 0x3f, 0xc7, 0xf8, 0x00, 0x01, 0xb7, 0x8f, 0xe1, 0xfc, 0x00, 
  0xff, 0xff, 0xe7, 0xfe, 0x7f, 0xf8, 0x7f, 0x03, 0xfc, 0x00, 0x01, 0xbf, 0xcf, 0xe0, 0x3c, 0x00, 
  0xff, 0xff, 0xe7, 0xfe, 0x7f, 0xfc, 0x7e, 0x01, 0xfc, 0x00, 0x01, 0x9f, 0x03, 0xe0, 0x0c, 0x00, 
  0xff, 0xff, 0xe7, 0xfe, 0x7f, 0xfe, 0x7e, 0x00, 0xfc, 0x00, 0x01, 0x8e, 0x01, 0xc7, 0x04, 0x00, 
  0x3f, 0xc7, 0xe3, 0xfc, 0x3f, 0xfe, 0x78, 0x00, 0x7c, 0x00, 0x01, 0x86, 0x78, 0x0f, 0x84, 0x00, 
  0x1f, 0x87, 0xc1, 0xf8, 0x1f, 0xfc, 0x78, 0x00, 0x3c, 0x00, 0x01, 0xc7, 0xfc, 0x1f, 0xcc, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xfc, 0x00, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe4, 0xe4, 0x1c, 0xee, 0x08, 0x30, 0xe6, 0x1c, 0x1f, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe4, 0x64, 0xec, 0xed, 0xfe, 0x73, 0x26, 0x7b, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe4, 0x24, 0xe4, 0xed, 0xfe, 0x73, 0x26, 0xfb, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe4, 0xc4, 0xe4, 0xee, 0x3e, 0x70, 0xe6, 0x3c, 0x7f, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe4, 0xe4, 0xe4, 0xef, 0xde, 0x73, 0x66, 0x7f, 0xbf, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe4, 0xe4, 0xec, 0xef, 0xce, 0x77, 0x26, 0xff, 0x9f, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe4, 0xe4, 0x1f, 0x1c, 0x3e, 0x77, 0x26, 0x18, 0x3f, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x3f, 0x3c, 0x3f, 0xf7, 0xfe, 0x1c, 0x7f, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};


//bitmaps: pickaxe, elytra, endBridging, crystal, sword, button

String text[] = {"Mining", "Flying", "Type", "Spammer", "Attack", "Clicker"};
/*Modes:
 * Mining: It mines for me in minecraft.
 * Flying: Continuously right clicks, which could be used to keep right clicking fireworks and fly.
 * Type: Part of another project that turns off computer.
 * Spammer: Discord aniversary stuff.
 * Attack: For afking at skeleton grinder.
 * Cliker: Keeps clicking (would point at button) to not get kicked for idling.
 */


int textX;
int textY;
int textW;
int textH;

int stringLength;
String newString;
int dontDisplay = 0;

int choosen = 0;

void checkTool() { //for mining mode
  int lightRead = digitalRead(lightPin);
  if(lightRead == 1) {
    Keyboard.print('5');
    toolMode = false;
  } else {
    Keyboard.print('6');
    toolMode = true;
  }
}
/* I put a color sensor in front of my screen. I also made a texture pack so gravel is white and stone is black.
 * So when the player is infront of gravel, it switches to a shovel using the hotbar key, and any other time it 
 * uses the pickaxe. Unfortunately, I only took a picture of this.
 */

void updateDisplay(int offset, int option) { //draws icons and message on display, offset is for moving the info when switching modes

  //display image based on option choosen
  switch(option) {
    case 0:
      display.drawBitmap(85 + offset, 20, pickaxe, 35, 35, WHITE);
      break;
    case 1:
      display.drawBitmap(85 + offset, 20, elytra, 35, 35, WHITE);
      break;
    case 2:
      display.drawBitmap(85 + offset, 20, endBridging, 35, 35, WHITE);
      break;
    case 3:
      display.drawBitmap(85 + offset, 20, crystal, 35, 35, WHITE);
      break;
    case 4:
      display.drawBitmap(85 + offset, 20, sword, 35, 35, WHITE);
      break;
    case 5:
      display.drawBitmap(85 + offset, 20, button, 35, 35, WHITE);
      break;
  }

  //draw Text
  display.setCursor(9 + offset, 31); 
  display.setTextColor(WHITE);
  display.setTextSize(2);
  display.cp437(true); 

  //if the text goes outside the bounds of the display, it would go to the next line, so I made this code
  //that keeps reducing the text until it fits.
  stringLength = text[option].length() - 2; 
  dontDisplay = 0;
  newString = text[option];
  display.getTextBounds(newString, 9 + offset, 31, &textX, &textY, &textW, &textH); 
  while(9 + offset + textW > 128) {
    newString = newString.substring(0, stringLength);
    stringLength--;
    if(stringLength < 0) { //eventually it will go completely off the screen, so this prevents an infinite loop
      dontDisplay = 1;
      break;
    }
    display.getTextBounds(newString, 9 + offset, 31, &textX, &textY, &textW, &textH);
  }
  if(dontDisplay == 0) {
    display.print(newString);
  }

  if(choosen == 1) {
    display.drawRect(3 + offset, 17, 123, 43, WHITE); //draws rectangle around if chosen
  }
}

int torch = 0;
int option1 = 0;

void choose() {
  state = !state;
}

int lastState = 1;

void setup() {
  pinMode(leftButton, INPUT_PULLUP);
  pinMode(centerButton, INPUT_PULLUP);
  pinMode(rightButton, INPUT_PULLUP);
  pinMode(lightPin, INPUT);
  pinMode(bluetooth, INPUT);

  attachInterrupt(digitalPinToInterrupt(7), choose, FALLING); //center button to turn on and off mode
  
  Serial.begin(9600);
  Mouse.begin();
  Keyboard.begin();
  
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("SSD1306 allocation failed"));
    for(;;);
  }

  display.clearDisplay();
  display.drawBitmap(0, 19, logo, 128, 45, WHITE);
  display.display();
  delay(2000);

  display.clearDisplay();
  updateDisplay(0, 0);
  display.display(); 
}

void checkButton() { //checks if button has been pressed, and if so updates display to show that, although it still has to finish the current loop
  if(state == HIGH) {
    state = LOW;
    if(choosen == 0) {
      choosen = 1;
      newMode = 1;
    } else {
      choosen = 0;
    }

    if(option1 == 2) {
      Mouse.release();
      Keyboard.releaseAll();
    }

    display.clearDisplay();
    updateDisplay(0, option1);
    display.display();

    delay(1000);
  }
}
  
void loop() {
  int right = digitalRead(rightButton);
  int center = digitalRead(centerButton);
  int left = digitalRead(leftButton);

  if(left == 0) { //moves left 
    choosen = 0;
    
    while(true) {
      display.clearDisplay();
      
      transition1 += 10;
      updateDisplay(transition1, option1);
      
      if(-128 + transition1 > 0) { 
        if(option1 + 1 > 5) {
          updateDisplay(0, 0);
          display.display();
          option1 = 0;
        } else {
          updateDisplay(0, option1 + 1);
          display.display();
          option1++;
        }
        break;
      } else {
        if(option1 + 1 > 5) {
          updateDisplay(-128 + transition1, 0);
        } else {
          updateDisplay(-128 + transition1, option1 + 1);
        }
      }
    
      display.display();
    }
    transition1 = 0;
  } else if(right == 0) { //moves right
    choosen = 0;
    
    while(true) {
      display.clearDisplay();
      
      transition1 -= 10;
      updateDisplay(transition1, option1);
      
      if(128 + transition1 < 0) {
        if(option1 - 1 < 0) {
          updateDisplay(0, 5);
          display.display();
          option1 = 5;
        } else {
          updateDisplay(0, option1 - 1);
          display.display();
          option1--;
        }
        break;
      } else {
        if(option1 - 1 < 0) {
          updateDisplay(128 + transition1, 5);
        } else {
          updateDisplay(128 + transition1, option1 - 1);
        }
      }
    
      display.display();
    }
    transition1 = 0;
  } 

  checkButton();
  if(newMode == 1) { //when I was trying to debug not starting immediently, switch messed up the specefic steps for mining
    //Keyboard.press('m');
    //Mouse.press(MOUSE_LEFT); //just started by pressing a button, then stops after two seconds to move on to the mode
    delay(2000);
    Keyboard.releaseAll();
    Mouse.release(MOUSE_LEFT);
    newMode = 0;
  }

  if(option1 == 0 && choosen == 1) { //mining mode
    checkTool();
    
    Mouse.press(); //mine top block
    if(toolMode == true) { //depending if it is using shovel or pickaxe, it mines longer or shorter for the tool
      delay(450);
    } else {
      delay(200);
    }
    Mouse.release();

    checkButton();
    checkTool();
    
    Mouse.move(0, 80, 0); //move down
    Mouse.move(0, 80, 0);

    delay(750);
    checkButton();
    checkTool();
    
    Mouse.press(); // mine bottom block
    if(toolMode == true) {
      delay(450);
    } else {
      delay(350);
    }
    Mouse.release();

    checkButton();
    checkTool();
    
    Mouse.move(0, -80, 0); //move back up
    Mouse.move(0, -80, 0);

    checkButton();
    checkTool();

    if(torch == 5) { //checks if it has moved enough blocks to place torch
      Mouse.move(80, 0, 0);
      Mouse.move(80, 0, 0); //move to the side

      checkButton();
  
      Mouse.press(MOUSE_RIGHT); //place torch
      delay(400);
      Mouse.release(MOUSE_RIGHT);

      checkButton();
  
      Mouse.move(-80, 0, 0); //move to center
      Mouse.move(-80, 0, 0);
      torch = 0;

      checkButton();
      checkTool();
    }

    Keyboard.press('w'); //move forward
    delay(300);
    Keyboard.releaseAll();

    checkButton();
    checkTool();

    torch++; //keep track how many blocks it has moved
    
    delay(500);

    checkButton();
    checkTool();
  } else if(choosen == 1 && option1 == 5) {
    Mouse.click(MOUSE_RIGHT);

    checkButton();
    
    delay(1000);
  } else if(choosen == 1 && option1 == 4) { //attack mode
    Mouse.click(MOUSE_LEFT);
    checkButton();
    
    delay(1000);
  } else if(choosen == 1 && option1 == 3) { //spammer mode
    /*Mouse.move(random(-500, 500), random(-500, 500), random(-500, 500));
    delay(10);*/  //use to just move randomly before
    for(int i = 0; i < 100; i++) {
      Keyboard.press('w');
      delay(15); //if it's too fast, discord crashes
    }
    delay(250);
    checkButton();
  } else if(choosen == 1 && option1 == 2) { //type mode, turns off computer when it pin changes from positive to negative
    /*/Keyboard.press(KEY_LEFT_SHIFT);
    Keyboard.press('w');
    //Mouse.press(MOUSE_RIGHT);
    checkButton();*/
    
    checkButton();
    delay(1000);
    int bState = digitalRead(bluetooth);
    Serial.println(bState);
    if(lastState != bState) {
      if(lastState == 1 && bState == 0) {
        Serial.println("changed");
        Keyboard.press(KEY_LEFT_CTRL);
        Keyboard.press(KEY_LEFT_GUI);
        Keyboard.press('q');
      }
      lastState = bState;
    }
    checkButton();
    delay(500);
    checkButton();
    Keyboard.releaseAll();
    checkButton();
  } else if(choosen == 1 && option1 == 1) { //flying mode
    Mouse.click(MOUSE_RIGHT);

    checkButton();
    
    delay(1000);
    checkButton();
    delay(1000);
    checkButton();
    delay(1000);
    checkButton();
    delay(1000);
    checkButton();
    delay(1000);
    checkButton();
    delay(1000);
    checkButton();
  } else { //just releases everything just in case anything is being pressed
    Mouse.release(MOUSE_LEFT);
    Mouse.release(MOUSE_RIGHT);
    Keyboard.releaseAll();
  }
}

//bitmaps: pickaxe, elytra, endBridging, crystal, sword, button
